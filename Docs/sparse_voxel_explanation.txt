- Tienes tres buffers y un atomic counter
-> el LUT: textura 3D 128x128x128 alienada con el mundo, RGBA8
-> el Atlas: textura 3D de por ejemplo 1024x1024x256 R8 que se usara como slots de 8x8x8, es decir  128x128x32 slots
-> la Lista: un buffer de shader storage de uint32 (o vec3 se puede hacer de varias formas), el tamaño puede ser variable pero el maximo seria el del total de slots en el atlas = 1024x1024x512 / 8
-> un atomic counter uint que llamaremos SlotCount

Tras modificar los strokes se hace los iguiente:

primer pass (solo tras modificar los strokes) - LUT Update: 
- lanzas compute shader de 128x128x128 para iterar cada voxel del LUT (dispatch de 16x16x16 con layout de 8x8x8 por ejemplo).
- conviertes la coordenada del compute + 0.5 en coordenada de mundo (centro del slot) y evaluas la lista de primitivas para saber la distancia en cada voxel.
- se guarda esta ditancia normalizada en voxeles (distancia en voxeles / 128), por ejemplo alpha.
- si la distancia es mayor de un determinado threshold fin de la ejecución de este shader
- si la ditancia es menor, se hace incrementa el SlotCount con: slot = atomicAdd(SlotCount) guardando el valor anterior
- el valor de slot se guarda en los tres canales restantes convirtiendo el indice en una coordenada normalizada de slot del Atlas (recuerda solo hay 128x128x32 slots)
- este valor de slot se utiliza como indice para escribir en el buffer de Lista, donde guardaremos el indice o coordenada del voxel de LUT.

segundo pass (solo tras modificar los strokes) - Atlas Update:
- se lee el valor de SlotCount en la CPU (quizá haya una forma mejor de hacer esto, no se me ha ocurrido)
- se landa un dispatch de (SlotCount, 1, 1) con un layout de 8x8x8 ( el tamaño de los los slots )
- con el gl_WorkGroupID.x del compute sabemos que slot estamos actualizando, y con gl_GlobalInvocationID la coordenada de la textura del Atlas en la que escribiremos, lo llamaremos sub_slot.
- calculamos el offset de posición relativa al centro del slot segun el sub_slot en el que estamos (agregando la mitad del tamaño del sub_slot para que sea su centro).
- calculamos la posición del mundo del centro sub_slot leyendo List[slot] la posición del mundo del slot y agregandole el offset del sub_slot.
- evaluamos la lista de primitivas con esta posición de mundo.
- guardamos la distancia en el Atlas[gl_GlobalInvocationID.xyz] en espacio de sub_slots dentro de un slot (8x8x8) (o quizá en world, no estoy seguro de si ya seria mejor en este punto)

tercer pass (modificar strokes y mover la cámara o cada frame) - raymarching:
- Raymarch contra la textura de LUT hasta encontrar un voxel cuya distancia sea menor a 1 voxel.
- **Si se encuentra un voxel cuya distancia es inferior a un voxel se hace se lee su slot y se hace raymarching contra ese slot.
- en ambos casos hay que hacer las conversiones de coordenada en sus respectivos espacios.
- si el raymarch en el slot encuentra una superficie se calcula la normal sampleando voxels adyacentes (pueden estar fuera de este slot) y se retorna el hit.
- si no se encuentra superifice, se continua el raymarch del LUT.

** El paso en el que se hace raymarching contra el atlas es complejo, hay que procurar no salirse del slot al samplear, es decir hay que modificar la coordenada 
de textura para que el trilinear no interpole con slots adyacentes. Este es ademas un paso que probablemente se pueda optimizar y encontrar la superficie con otros 
métodos matematicos que aún no he sido capaz de entender, como resolver un limite utilizando varios samples a lo largo del rayo dentro del slot.

Tampoco hay manera de guardar el material Id o color. En otras implementaciones he visto que el atlas es de RGBA8 y se guarda el color al valuar el stroke  (pero sin parametros de material), 
esto queda bién pq el color se blendea con el trilinear, pero un material Id seria inviable, parametros de material directamente también podria funcionar (roughness, metalness, y que el color 
sea un gradient u ocupar 2 slots y que uno sea para el color).


references:

https://twitter.com/SebAaltonen/status/1317517477706895362?s=20&t=lUktmhLppdVuBMWqmHKBUQ
https://directtovideo.wordpress.com/2013/05/07/real-time-ray-tracing/
https://directtovideo.wordpress.com/2013/05/08/real-time-ray-tracing-part-2/

https://twitter.com/SebAaltonen/status/983977606897905666